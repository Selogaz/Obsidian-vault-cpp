---
tags:
  - note/specific/code
  - category/java
aliases:
  - Stream API
deck: obsidian::java
created: 2025-09-19T20:42:10+03:00
updated: 2025-10-09T16:27:51+03:00
sr-due: 2025-10-19
sr-interval: 10
sr-ease: 282
---

**Stream API**
—
появился в [[java 8]] как альтернатива обработки данных через циклы for.
✅ Читаемость: стандартные методы, которые написаны по порядку
✅ Легко распараллелить обработку данных через `parallel()`
✅ Исходные данные не меняются, код более предсказуем

❌ Промежуточные операции не поддерживают `checked exceptions`
❌ Сложность отладки, нельзя поставить брейкпоинт в середину стрима. Тут может помочь метод `peek` и механизмы IDE.
❌ Обработка занимает чуть больше времени: стрим производит много промежуточных объектов и дополнительных действий. ✅ На больших объемах нивелируется добавлением `parallel()`
❌ За один проход по исходной коллекции можно решить только одну задачу
❌ Можно работать только с одним источником данных

# Свойства Stream API
![[java свойства Stream API]]

# Структура Stream API
java структура Stream API
- Источник (Source): Коллекция, массив, генератор
- Промежуточные операции (Intermediate): filter, map, sorted, ...
- Терминальная операция (Terminal): collect, count, max, forEach, reduce, ...

# Внутренние характеристики Stream API

Стрим содержит набор характеристик, которые описывают данные, с которыми он работает. Они зависят от источника данных и промежуточных операций.

Ленивость Stream API позволяет учесть все характеристики перед выполнением стрима и подобрать оптимальных вариант выполнения. Если данные пришли из списка и отсортированы (SORTED), их не нужно сортировать повторно. Если коллекция содержит уникальные элементы (DISTINCT), можно избежать дополнительных проверок на уникальность.

Промежуточные операции могут изменить эти характеристики. Например, map сбрасывает флаги SORTED и DISTINCT, но оставляет флаг SIZED.

# Промежуточные операции Stream API

## Разница map и flatmap

`map` выполняет преобразование элемента. Например, "str" -> "STR".
`flatMap` превращает "список элементов" в плоский список. В аргументах указывается метод преобразования списка в стрим.
```java
Stream.of(List.of(1, 2), List.of(3, 4))  // [[1, 2], [3, 4]]
.flatMap(List::stream)
.toList(); // [1, 2, 3, 4]

```

`peek` используется для отладки или выполнения побочных действий(логирование, статистика) без изменения элементов. Применять его для выполнения произвольной логики с элементами считается плохой практикой

`takeWhile` (java 9+) вернет непрерывную последовательность элементов, выполняющий условие. При первом отказе перестает действовать
```java
List.of(1, 2, 3, 4).takeWhile(x -> x < 3).toList() // [1,2]

```
`dropWhile` (java 9+) работает наоборот - отбрасывает элементы потока, пока условие не начнет выполняться
```java
List.of(1, 2, 3, 4, 5).dropWhile(x -> x < 3).toList() // [3, 4, 5]

```

# Коллекторы

- toList(), toSet() - собирают результаты. В [[java ArrayList|ArrayList]] и [[java HashSet|HashSet]]
- joining - соединяет элементы в одну строку. Под капотом использует StringBuilder и минимизирует количество промежуточных объектов
- toMap, toConcurrentMap собирают элементы в Map

Если ключи повторяются, то вылетит `IllegalStateException`. Чтобы этого избежать, третьим параметром можно объяснить, как объединять значения:
```java
collect(toMap(Student::city, Student::name, (a,b) -> a + " " + b));

```
Это похоже на группировку по городу, но это не она. Элементы объединяются в один элемент, а не в группу.

- groupingBy группирует элементы. По умолчанию они собираются в список:
```java
// списки студентов по городам
Map<String, List<Student>> = …collect(groupingBy(Student::city))

```
Чтобы собирать элементы в другую структуру, нужно передать коллектор вторым параметром:
```java
Map<String, Set<Student>> res = …collect(groupingBy(Student::city, toSet())

```
Можно передать специальные коллекторы, чтобы выполнить преобразования над группой
```java
// количество студентов по городам
Map<String, Long> reslres = lect(collectgroupingBy(Student::city, counting()))

```
Список коллекторов для использования вместе с groupingBy:
- averagingToInt / Long / Double
- maxBy, minBy
- reducing
- mapping / flatMapping
- filtering
- `partitioningBy` - делит элементы на две группы по заданному условию. В итоге получается map с двумя ключами: true и false. Это частный случай группировки, и часто того же результата можно добиться более простыми средствами.
- `summarizing` - возвращает объект `SummaryStatistics`, который содержит минимум, максимум, среднее, количество элементов и их сумму. Есть для Integer, Long и Double.

Другие терминальные операции

- toList() - в отличие от collect(Collectors.toList()) возвращает неизменяемый список

# Параллельная обработка элементов

Если добавить `parallel` в любом месте стрима, стрим будет разделен на части, каждая из которых будет обработана отдельным потоком. Параллелизация требует накладных расходов на выполнение, поэтому рекомендуется только для больших наборов данных (более 10к элементов) или сложных вычислений.

В параллельном режиме не гарантируется сохранение порядка.

Потоки берутся в `ForkJoinPool.commonPool()`. В этом пуле число потоков = числу ядер, он один на всё приложение. Поэтому не рекомендуется выполнять в параллельном режиме I/O-bound операции: чтение из файла, БД, запросы в другие сервисы и тд.

# Работа с примитивами

Работа с примитивами через `Stream<T>` приводит к автоупаковке и распаковке. Это увеличивает потребление памяти и время работы. Специализированные стримы (IntSream, LongStream, DoubleStream) решают эти проблемы, обеспечивая работу непосредственно с примитивами без автоупаковки.

# Популярные ошибки

❌ Терминальную операцию forEach рекомендуется использовать только в крайнем случае, так как он не возвращает результат, а работает только за счет побочных эффектов
❌ При извлечении данных из БД нужно фильтровать их на стороне БД, а не использовать для этого Stream API на уровне приложения
```java
userRepository.findAll().stream().filter(…)…

```

# Дополнительные материалы
[[Документация Stream API]]
[[Наглядно про операции Stream API]]
