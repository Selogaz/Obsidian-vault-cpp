---
tags:
  - note/specific/code
  - category/java
aliases:
  - сборка мусора
deck: obsidian::java
created: 2025-10-01T21:51:19+03:00
updated: 2025-10-08T18:58:14+03:00
sr-due: 2025-10-12
sr-interval: 4
sr-ease: 302
---

**сборка мусора**
—
garbage collection - процесс освобождения памяти путем удаления неиспользуемых объектов из кучи.

Гипотеза поколений - эмпирическое наблюдение, согласно которому большинство объектов становятся не нужны почти сразу после создания, а оставшиеся живут значительно дольше.

Во многих сборщиках мусора куча делится на несколько "поколений", для которых применяются разные алгоритмы и частота сборки мусора.

Типы поколений:
- Молодое поколение ([[young generation]]): сюда попадают все "недавние" объекты, самые вероятные кандидаты для сборки мусора. Включает подрегионы:
	- Eden - для новых объектов
	- Survivor spaces (S0 и S1) - промежуточные области, куда объекты перемещаются после чистки Eden, если они живы.
- Старое поколение ([[old generation]]/Tenured Generation): объекты, пережившие несколько сборок молодого поколения. Обрабатывается реже, т.к. объекты здесь, как правило, живут долго.

Сборка мусора делится на 3 этапа:
- [[minor collection|Minor GC]](молодое поколение): частые, быстрые сборки в [[young generation]] (особенно в Eden)
- Major GC (старое поколение): происходит реже и занимает больше времени, т.к. требует обработки объектов старого поколения, которые могут быть живы долго
- Full GC = Minor GC + Major GC

Сборщик мусора запускается, когда память в куче или определенном регионе заканчивается или приближается к лимиту. Из кода можно вызвать `System.gc()`, это рекомендация [[JVM]] запустить Major GC. Вызывать `System.gc()` является плохой практикой, так как сборщик мусора лучше определяет, когда запускаться.

# [[виды сборщиков мусора|Типы сборщиков мусора]]

# Как сборщик мусора ищет объекты для удаления

## Граф достижимости

Сборщик строит граф живых объектов. Начинает с [[GC Roots]], затем посещает все объекты, на которые они ссылаются. Объекты, которые не попали в граф, считаются мусором.

GC Roots - объекты, с которых начинается обход графа объектов. Основные: статические объекты, активные потоки и их локальные переменные, объекты в стеке вызовов, служебные объекты JVM.

## Алгоритм "подсчет ссылок" (устаревший)

Каждый объект хранит количество ссылок на него. Когда счетчик становится равным нулю, объект считается недостижимым.

Недостатки:
- ❌ [[циклическая зависимость|циклические ссылки]]: если объекты ссылаются друг на друга, но недостижимы через [[GC Roots]], такие объекты не будут удалены
- ❌ низкая производительность: постоянные обновления счетчиков при каждой созданной или уничтоженной ссылке

# Настройка сборщика мусора

Каждый сборщик балансирует между параметрами: latency (максимальное время обработки запроса), throughput (сколько запросов обрабатывается в минуту) и memory footprint (объем потребляемой памяти). "Запрос" - взаимодействие приложения с памятью: создание, обновление и удаление объектов.

Приоритет зависит от приложения:
- Для веб-сервисов большие задержки недопустимы. Лучше в среднем ответ будет на четверть секунды дольше, но не будет подвисших запросов.
- Приложение работает в фоновом режиме. Например, архивирует записи. Не критично, если каждая сотая запись будет архивироваться 5 секунд, если за час обработается больше данных.

# Дополнительные материалы
[Подробное описание работы сборщиков мусора](“Java Highload и сборка мусора” ([mrtxee, 2025](zotero://select/library/items/VGCFRIGY)) ([snapshot](zotero://open-pdf/library/items/7YPWE3WD?sel=h1%20%3E%20span&annotation=AR72X689)))
[Примеры оптимизации сборщика мусора](“Garbage Collection и JVM” ([badcasedaily1, 2023](zotero://select/library/items/PENHPP9I)) ([snapshot](zotero://open-pdf/library/items/64EQ4TY4?sel=h1%20%3E%20span&annotation=PCA6LFU9)))
[Примеры оптимизации сборщика мусора](“Garbage Collection и JVM” ([badcasedaily1, 2023](zotero://select/library/items/PENHPP9I)) ([snapshot](zotero://open-pdf/library/items/64EQ4TY4?sel=h1%20%3E%20span&annotation=PCA6LFU9)))
[Бенчмарки сборщиков мусора для Java](“Производительность современной Java при работе с большим объёмом данных, часть 1” ([AloneCoder, 2020](zotero://select/library/items/EFLY7HAH)) ([snapshot](zotero://open-pdf/library/items/XA8RW73T?sel=h1%20%3E%20span&annotation=W84J8G2P)))
