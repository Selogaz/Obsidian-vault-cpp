---
tags:
  - note/specific/code
  - category/java
aliases:
  - Уровни изоляции
deck: obsidian::java
created: 2025-08-14T09:54:36+03:00
updated: 2025-10-08T19:12:19+03:00
sr-due: 2025-10-12
sr-interval: 4
sr-ease: 270
---

**Уровни изоляции**
—
```table-of-contents
```
определяют как транзакции взаимодействуют между собой, с какими данными работают и какие проблемы (аномалии) допустимы.

# Аномалии при параллельных транзакциях:

### Грязное чтение

транзакция может прочитать данные других транзакций, которые еще не закоммичены

Пример:
- Транзакция А меняет баланс счета с 1000 на 2000, но еще не подтвердила изменения
- Транзакция В читает новый баланс 2000 и начисляет на них проценты.
- Транзакция А откатывается (баланс снова 1000), но транзакция В уже *использовала неверные данные* и начислила много процентов

### Неповторяющееся чтение

В рамках одной транзакции данные конкретных строк непостоянны и при повторном извлечении могут отличаться.

Пример:
- Транзакция А читает баланс 1000
- Транзакция В изменяет баланс на 2000 и фиксирует изменения
- Транзакция А снова читает баланс и видит 2000. *Логика, основанная на первоначальных данных, становится недействительной*

На практике один и тот же запрос в рамках транзакции редко выполняется. Ошибка часто возникает, если в транзакции идёт работа с несколькими агрегатными функциями (avg, sum и тд)

### Фантомное чтение

В рамках одной транзакции набор данных, удовлетворяющий условию, может измениться.

Пример:
- Транзакция А считает сумму на всех счетах клиента (допустим, их 5)
- Транзакция В добавляет новый счет и фиксирует изменения
- Транзакция А считает количество счетов и получает 6. Результат посчитан на основе "фантомных" записей, которых изначально не было, и дальнейшие расчеты будут ошибочными.

Аномалии выше часто упоминаются как *основа для обсуждения* уровня изоляций. На практике часто встречаются еще и такие аномалии:

### Грязная запись
Одна транзакция записала какое-то значение, но еще не зафиксировала это, а вторая транзакция перезаписала это незафиксированное значение.

Пример: два пользователя одновременно пытаются изменить баланс одного и того же счета. Изначальный баланс: 1000
- Транзакция А (начислить 500) прочитала 1000, вычислила новый баланс как 1500, но не закоммитила изменения
- Транзакция В (списать 300) прочитала незафиксированные 1500, вычла 300, записала 1200 и закоммитила
- Транзакция А откатилась. В итоге на балансе 1200, но должно быть 700

### Потерянное обновление

Потеря изменений транзакции. Возникает, когда две транзакции вычисляют новое значение на основе исходного и не учитывают изменения друг друга

Пример: два пользователя пытаются изменить баланс одного и того же счета. Изначальный баланс 1000.
- Транзакция А (начислить 500) прочитала 1000, высилила новый баланс как 1500
- Транзакция В (списать 300) прочитала 1000, вычла 300, закоммитила 700
- Транзакция А записала значение баланса 1500. В итоге на балансе 1500, изменения транзакции В потеряны

### Асимметрия записи

Транзакции одновременно читают одни и те же данные, принимают решения на их основе, а затем записывают изменения, которые конфликтуют друг с другом, нарушая бизнес-правила.

Каждая транзакция изменяет разные строки, но логически они связаны.

Пример: Врач может уйти с дежурства, если на дежурстве есть другие врачи. Сейчас на дежурстве 2 врача: Анна и Борис
- Транзакция А Анна, проверяет, есть ли дежурные врачи, помимо Анны. Есть, это Борис
- Транзакция В Борис проверяет, есть ли дежурные врачи, помимо Бориса. Есть, это Анна
- Транзакция А: Анна уходит с дежурства и обновляет запись в таблице
- Транзакция В: Борис уходит с дежурства и обновляет запись в таблице. В итоге бизнес-правило нарушено

# Уровни изоляции в стандарте SQL

- Read Uncommitted - возможны все аномалии
- Read Commited - запрещает грязное чтение
- Repeatable Read - запрещает грязное и Неповторяющееся чтение
- Serializable - аномалий нет, транзакции выполняются, как будто они идут одна за другой

# Уровни изоляции на практике

У каждой БД есть свои небольшие особенности. Например, в Postgres:
- По умолчанию используется Read Commited
- Грязные чтения из других транзакций невозможны даже на уровне Read Uncommited
- На уровне Repeatable Read не допускаются фантомные чтения, но возможен откат транзакций в случае обнаружения конфликтов
- Последовательное сканирование (full scan) влечёт за собой предикатную блокировку на уровне таблицы и увеличивает вероятность откатов на уровнях Repeatable Read и Serializable

# Как реализованы уровни изоляции в Postgres

Когда-то давно изоляция в БД реализовывалась с помощью локов на разных уровнях (поле, строка, таблица). Отсюда пошло утверждение, что чем строже уровень изоляции, тем сильнее он сказывается на производительности.

Сейчас в большинстве БД изоляция достигается с помощью многоверсионности (<font color="#ffff00">MVCC</font>) - в базе одновременно находятся несколько версий (снимков, снэпшотов) данных. Разные транзакции работают с разными версиями, и так достигается изоляция. Уровень изоляции определяется тем, когда создается снимок данных:

Read Commited - снимки данных строятся в начале выполнения каждого оператора SQL. Оператор работает с неизменной картиной данных, но два одинаковых запроса, следующих один за другим, могут показать разные данные

Repeatable Read - снимок строится в начале транзакции при выполнении первого оператора, поэтому все запросы в одной транзакции видят одни и те же данные. Транзакция может откатиться при возникновении конфликтов.

Serializable - так же, как в Repeatable Read плюс на таблицу накладываются предикатные [[java блокировки|блокировки]] (SILocks, это ведь одно и то же?), которые помогают лучше обнаруживать конфликты.

# Альтернативы

Часто аномалии можно нивелировать другими средствами:
- Атомарный апдейт
```sql
UPDATE accounts SET balance = balance + 100;
```
- [[java блокировки|блокировки]]
```sql
SELECT * FROM items FOR UPDATE;
```
- Ограничения целостности - уникальность, внешние ключи или ограничения на конкретные значения
- Материализация конфликтов - создание в базе объектов, на которые можно было бы повесить [[java блокировки|блокировку]] SELECT FOR UPDATE для превращения фантома в конфликт.

# Дополнительные материалы

[Нюансы уровней изоляции в Postgres](“Изоляция транзакций” ([“Нюансы уровней изоляции в Postgres”](zotero://select/library/items/EMM754UK)) ([snapshot](zotero://open-pdf/library/items/6ZJLIGY4?sel=h2&annotation=ERHVI5JT)))
[Как реализована многоверсионность в Postgres](“Многоверсионность” ([“Как реализована многоверсионность в Postgres”](zotero://select/library/items/3LRY8J5Q)) ([snapshot](zotero://open-pdf/library/items/KG6A4KWC?sel=%23pf3%20%3E%20div%3Afirst-child%20%3E%20div%20%3E%20div%3Anth-child(4)&annotation=43L9KF8T)))
[Как работают разные команды на разных уровнях изоляции в Postgres](“Изоляция транзакций” ([“Как работают разные команды на разных уровнях изоляции в Postgres”](zotero://select/library/items/WDCTAC9J)) ([snapshot](zotero://open-pdf/library/items/M3II9QJI?sel=h2&annotation=PL55R4V7)))
[Простые примеры SQL с демонстрацией ошибок изоляции](“Уровни изоляции транзакций в БД” ([ListenIT, 2024](zotero://select/library/items/I9G8SXYA)) ([snapshot](zotero://open-pdf/library/items/D8DJ6UDS?sel=h1%20%3E%20span&annotation=WZHC5G7J)))
[Уровни изоляции в Postgres, много сложных примеров](“Transaction Isolation Levels in PostgreSQL” ([“Уровни изоляции в Postgres, много сложных примеров”](zotero://select/library/items/2KSJP3TK)) ([snapshot](zotero://open-pdf/library/items/J2RYCTJ8?sel=%23card-talk-1588408%20%3E%20h2&annotation=YMENVE6V)))

изоляции транзакций определяют, как транзакции взаимодействуют друг с другом при одновременном доступе к данным
1. Грязное чтение:

    - Транзакция A читает данные, измененные транзакцией B, но не зафиксированные. Если транзакция B откатывается, данные становятся некорректными.
    - Решение: `READ COMMITTED` и выше.
2. Неповторяющееся чтение:

    - Транзакция A дважды читает одну и ту же строку, но между чтениями транзакция B изменяет и фиксирует эту строку.
    - Решение: `REPEATABLE READ` и выше.
3. Фантомное чтение:

    - Транзакция A выполняет один и тот же запрос дважды, но между запросами транзакция B добавляет новые строки, которые удовлетворяют условиям запроса.
    - Решение: `SERIALIZABLE`.
