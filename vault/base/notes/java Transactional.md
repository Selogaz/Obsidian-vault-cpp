---
tags:
  - note/specific/code
  - category/java
aliases:
  - Transactional
deck: obsidian::java
created: 2025-08-14T09:57:04+03:00
updated: 2025-09-20T08:41:49+03:00
---

**Transactional**
—
фиксирует или откатывает транзакцию в зависимости от успеха операции
Когда метод помечен как `@Transactional`, Spring создает прокси-объект, который управляет транзакцией:

1. **Начало транзакции**: Перед выполнением метода открывается новая транзакция.
2. **Фиксация (commit)**: Если метод завершается успешно, транзакция фиксируется.
3. **Откат (rollback)**: Если в методе выбрасывается исключение, транзакция откатывается.

выполняет указанный метод внутри транзакции. Можно поставить над классом - тогда каждый метод будет запущен в рамках транзакции.

Основные параметры и значения по умолчанию:
```java
@Transactional(
  propagation = Propagation.REQUIRED,   // Стратегия распространения транзакции
  isolation = Isolation.READ_COMMITTED, // Уровень изоляции
  timeout = 30,                         // Таймаут в секундах, прежде чем будет выброшен TransactionTimedOutException
  readOnly = false,                     // Режим "только чтение" (false по умолчанию)
  rollbackFor = {},                     // Откатить при указанных исключениях, по умолчанию откатываются все RuntimeException
  noRollbackFor = {}                    // Не откатывать при указанных исключениях
)

```

# Параметр propagation

определяет, что делать, если в рамках уже существующей транзакции вызвали транзакшн метод.

- REQUIRED (по умолчанию) - если есть активная транзакция - метод её использует. Если нет - создает новую.
- REQUIRES_NEW - всегда создает новую транзакцию, приостанавливая текущую (если есть)
- SUPPORTS - работает в транзакции, если она есть, иначе - без неё
- NOT_SUPPORTED - выполняется вне транзакции, приостанавливая текущую (если есть)
- MANDATORY - выбрасывает исключение, если запускается вне транзакции
- NEVER - запрещает выполнение в транзакции, иначе - исключение
- NESTED - создает точку сохранения (savepoint) в рамках текущей транзакции. Если внутри метода возникает исключение, то откатываются изменения, сделанные в этом методе. Внешняя транзакция остаётся активной.

# Параметр readOnly

сообщает Spring и драйверу бд, что транзакция предназначена только для чтения данных. На что может влиять:
- для JPA/[[java Hibernate|Hibernate]] отключается механизм dirty checking: изменения сущностей не отслеживаются и не сохраняются, что экономит ресурсы и ускоряет выполнение запросов.
- Многие СУБД могут оптимизировать выполнение: не ставить эксклюзивные блокировки, выбирать более быстрые планы выполнения, иногда использовать отдельные read-only реплики
- Если попытаться изменить данные (insert, update, delete) в такой транзакции, Spring или база могут выбросить исключение

readOnly = true - оптимизация и некоторая защита от случайных изменений. Контроль не жесткий, поэтому не рекомендуется делать изменения внутри таких транзакций.

# Параметр transactionManager

явно задаёт имя бина менеджера транзакций, если в приложении их несколько. Нужно для работы с разными источниками данных.

# Поведение при ошибках

Транзакция откатывается, если:
- В коде сервиса возникло исключение, указанное в rollbackFor
- По умолчанию транзакция откатывается при unchecked исключениях
```java
(rollbackFor = { RuntimeException.class })

```
- SQL запрос выполняется через Spring Data репозиторий. В этом случае любые SQL ошибки выбрасывают [[java DataAccessException|DataAccessException]], оно unchecked
- Возникшее исключение перехвачено в try-catch внутри Transactional метода. В этом случае оно не дойдет до обработчика в прокси

Транзакция не откатывается, если:
- В коде сервиса возникло checked исключение
- SQL запрос выполняется через jdbcTemplate и во время исполнения SQL-запроса возникает ошибка. JDBC-драйвер выбрасывает SQLException, оно checked
- Исключение указано в параметре noRollbackFor

# Как @Transactional работает под капотом

Spring создает прокси для метода, помеченного `@Transactional`, и управляет открытием/закрытием транзакции через интерфейс TransactionalManager (его реализация - PlatformTransactionManager)

`@Transactional` над методом m в классе Service превращается примерно в такой код:
```java
public class Proxy{
  private Service targetService;
  public void m{
    //код начала транзакции
    try {
       service.m();
    } catch (RuntimeException e) 
      // откат транзакции
   finally {
      //код конца транзакции
  }
}

```

# Рекомендации по работе с Transactional

- НЕ использовать Transactional для private методов
	- т.к. прокси не сможет переопределить такой метод. Транзакция не будет создана или применена.
- Не вызывать транзакционные методы из того же класса внутри одного класса. Транзакция не будет создана, так как вызов пойдет напрямую в метод, минуя прокси
- Проверять, что добавляется в импорт. Спринг работает с аннотациями org.springframework.transaction.annotation. Есть похожая аннотация jakarta.transaction.Transactional с меньшими возможностями
- Использовать readOnly = true везде, где это возможно
- Ставить аннотацию Transactional на уровне сервисов, а не контроллеров и репозиториев

# Логирование транзакций

```yaml
logging:
   level:
      org.springframework.orm.jpa: DEBUG
      org.springframework.transaction: DEBUG

```

# Альтернативы Transactional

TransactionTemplate используется, когда требуется точный контроль над транзакциями..

# Интересные факты про Transactional

- Распределенные транзакции
	- можно выполнять через Transactional. Для этого нужно настроить jtaTransactionManager, который интегрируется с внешним координатором транзакций - Atomikos, Narayana, Bitronix
- Интеграционные тесты
	- Если поставить аннотацию над интеграционным тестом, все изменения БД, которые произошли в рамках теста, происходят в рамках транзакции. В конце теста она откатывается, и база возвращается к исходному состоянию
- Физическая и логическая транзакции
	- Логическая - группа операций, которые с точки зрения бизнес-логики должны быть выполнены как единое целое (перевод денег между счетами: списание и зачисление).
	- Физическая - транзакция, границы которой определяются механизмами СУБД (например, командами BEGIN/COMMIT/ROLLBACK), и которая обеспечивает автомарность выполнения операций на уровне БД.
	- Разные значения `propagation` приводят к разному соотношению между физическими и логическими транзакциями

# Дополнительные материалы
[[Подробное объяснение механизма работы Transactional (eng)]]
[[Пересказ английской документации по Transactional с примерами]]
[[Как и какие классы обрабатывают код внутри Transactional]]
[[Как сделать распределенные транзакции через Transactional (eng)]]
[[Пример настройки нескольких DataSource и распределенных транзакций (eng)]]
[[Демонстрация работы разных propagation]]
