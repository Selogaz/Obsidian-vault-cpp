---
tags:
  - note/specific/code
  - category/java
aliases:
  - как запустить задачу в другом потоке
deck: obsidian::java
created: 2025-09-19T19:57:27+03:00
updated: 2025-09-19T19:57:27+03:00
---

**как запустить задачу в другом потоке**
—
# Явное создание потоков
В Java многопоточность реализуется через класс Thread и интерфейс Runnable. Выполнить код в отдельном потоке можно двумя способами:
- Наследоваться от класса Thread и переопределить метод run:
```java
class MyThread extends Thread {     
   public void run() {  /* асинхронная задача */ } 
} 

MyThread thread = new MyThread(); 
thread.start();

j```
- Передавать в экземпляр Thread реализацию Runnable интерфейса:
```java
Runnable task = () -> { /* асинхронная задача */ }

Thread thread = new Thread(task); 
thread.start();

```
При вызове Thread.start() [[JVM]] создает поток в операционной системе и связывает его с объектом Thread. В новом потоке вызывается метод run().
Соотношение между потоками ОС и экземплярами Thread 1:1, поэтому нельзя вызвать start() повторно на том же объекте. Получим исключение IllegalThreadStateException.

Работать с потоками напрямую неудобно: много кода, неудобно извлекать результат, нельзя переиспользовать потоки, сложно управлять группой потоков. Поэтому на практике используются другие способы.

# Отправить задачу в экзекьютор

Экзекьютор состоит из очереди задач и пула потоков:
```java
ExecutorService executor = Executors.newFixedThreadPool(4);

executor.execute(() -> {
    // асинхронная задача 
});

```
✅ Плюсы:
- Потоки переиспользуются
- Гибкие настройки и простота конфигурации
- Удобные фабричные методы в классе Executors
❌ Минусы:
- По умолчанию нет обработки исключений внутри потоков
- Нужно явно закрывать [[java ExecutorService|ExecutorService]] методов shutdown/shutdownNow, чтобы освободить ресурсы

В экзекьютор можно отправить задачи 2 типов:
- Runnable - интерфейс для задач, которые не возвращают результат и не могут выбросить проверяемые исключения
- Callable - интерфейс для задач с результатом:
```java
Callable<Integer> task = () -> 42; 
Future<Integer> future = executorService.submit(task);

```

# CompletableFuture

API для асинхронного программирования, появившийся в Java 8. По умолчанию задачи отправляются в общий пул потоков `ForkJoinPool.commonPool()`, но можно передать и свой экзекьютор
```java
CompletableFuture
        .supplyAsync(() -> { /* асинхронная задача */ })
        .thenAccept(result -> {/* действие с результатом */});

```
- Легко создать цепочку вызывов (thenApply, thenAccept, thenRun)
- Легко организовать взаимодействие нескольких потоков (дождаться всех или любого из группы)
- Методы для обработки исключений

# Аннотация @Async в Spring

Чтобы отправить задачу в экзекьютор, нужно включить в конфигурации поддержку асинхронности @EnableAsync и пометить метод аннотацией @Async:
```java
@Service
public class MyService {
    @Async
    public void asyncMethod() {
        // Метод выполнится в отдельном потоке
    }

```
✅ Минимум кода
✅ Экзекьютор, в котором будет выполняться код, можно переопределить
❌ Работает только для методов в бинах
❌ По умолчанию нет обработки исключений
