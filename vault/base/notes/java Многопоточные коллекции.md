---
tags:
  - note/specific/code
  - category/java
aliases:
  - Многопоточные коллекции
deck: obsidian::java
created: 2025-09-19T21:59:44+03:00
updated: 2025-10-08T19:17:52+03:00
sr-due: 2025-10-12
sr-interval: 4
sr-ease: 276
---

**Многопоточные коллекции**
—
Предназначены для одновременной работы нескольких потоков.

Обычные коллекции не подходят для работы в многопоточной среде. Если несколько потоков одновременно модифицируют [[java ArrayList|ArrayList]], [[HashMap]] возможны:
- гонки данных (race conditions)
- неконсистентные состояния коллекции
- исключения времени выполнения (например, ConcurrentModificationException)

Стандартные коллекции не используют синхронизацию: все операции выполняются максимально быстро, но без защиты от одновременного доступа нескольких потоков.

Неизменяемые коллекции могут использоваться в многопоточной среде для чтения. Это коллекции типа CopyOnWrite, Coolections.unmodifiable, Map.of(), List.of(),Set.of()

# Списки

CopyOnWriteArrayList - список на основе массива, при модификации которого создаётся новая копия. После модификации новый массив становится "основным". При таком подходе можно не накладывать блокировки на чтение, так как старый массив остаётся неизменным для читателей. Оптимален для сценариев с частыми чтениями и редкими изменениями.

# Сеты

ConcurrentSkipListSet - упорядоченное множество элементов на основе skip list

CopyOnWriteArraySet - потокобезопасное множество, при модификации которого создаётся новая копия внутреннего массива. Сделан на основе CopyOnWriteArrayList, при добавлении вызывается его метод addIfAbsent

# Очереди

Блокирующие - очереди, которые при попытке достать элемент из пустой очереди блокируют вызывающий поток, пока элемент не появится. Также поток блокируется при попытке вставки в полную очередь. Блокировки полезны для регулирования нагрузки.

Неблокирующие очереди в тех же ситуациях не блокируют поток, а сразу отдают null или false.

Выбор зависит от требований: гарантированная обработка и контроль нагрузки - блокирующие очереди, максимальная скорость - неблокирующие.

- LinkedBlockingQueue - блокирующая очередь на основе связного списка, размер можно ограничить
- ArrayBlockingQueue - блокирующая очередь на основе массива, размер задаётся на старте
- ConcurrentLinkedQueue - неблокирующая неограниченная очередь на основе связного списка
- SynchronousQueue - очередь, в которой каждый элемент при вставке должен ждать, пока другой поток его извлечёт, и наоборот. Не хранит элементы, используется для передачи данных 1 к 1.
- LinkedTransferQueue - неблокирующая, неограниченная очередь на основе связного списка. Позволяет как обычное добавление элементов, так и "гарантированную передачу" - когда производитель ждёт, пока потребитель заберёт элемент
- PriorityBlockingQueue - неограниченная блокирующая очередь с приоритетом, основанная на куче(heap)
- DelayQueue - неограниченная блокирующая очередь, элементы извлекаются только по истечении заданной задержки (элементы должны реализовать интерфейс Delayed). Используется для отложенных задач

# Двунаправленные очереди

- ConcurrentLinkedDeque - неблокирующая, работает медленнее ConcurrentLinkedQueue
- LinkedBlockingDeque - блокирующая

# Map

- Hashtable - устаревшая реализация. Похожа на ранний вариант HashMap, все методы обозначены как synchronized. Не допускает null ключей и значений
- Collections.synchronizedMap(map) создаёт обёртку над любой переданной Map. Каждый метод синхронизируется через synchronized(mutex)
- ConcurrentHashMap - синхронизация по бакетам, чтение без блокировок. *В каждый момент времени с map может работать число потоков, равное числу бакетов*
- ConcurrentSkipListMap - реализация на основе структуры skip list. Обеспечивает упорядоченное хранение элементов

# Другие коллекции

Collections.synchronized добавляет synchronized обёртку для любой переданной коллекции
```java
List<String> list = Collections.synchronizedList(new ArrayList<>())

```

[[Документация java util concurrent]]
