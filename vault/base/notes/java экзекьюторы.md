---
tags:
  - note/specific/code
  - category/java
aliases:
  - экзекьюторы
deck: obsidian::java
created: 2025-09-19T19:58:04+03:00
updated: 2025-10-08T18:54:11+03:00
sr-due: 2025-10-12
sr-interval: 4
sr-ease: 270
---

**экзекьюторы**
—
# Экзекьюторы

Классы в java.util.concurrent, которые упрощают работу с потоками. Являются реализацией паттерна Thread Pool.

Суть паттерна: *вместо создания и уничтожения потоков для каждой задачи заранее создается фиксированное количество потоков* (пул). Задачу выполняет свободный поток из пула. Когда задача выполнена, поток возвращается в пул.

✅ Упрощается работа с потоками: экзекьюторы берут на себя создание, переиспользование и утилизацию потоков
✅ Экономится время и ресурсы, т.к. *потоки переиспользуются, а не создаются заново* для каждой задачи

Размер пула можно ограничить. И таким образом влиять на размер памяти, который занимают потоки и на пропускную способность системы.

## Основные классы экзекьюторов

[[java ExecutorService|ExecutorService]] - интерфейс ля экзекьюторов, содержит метод execute(Runnable), который принимает задачу для выполнения, и методы для управления жизненным циклом экзекьютора(submit, invokeAll, shutdown и др)

При отправке задачи в экзекьютор сразу возвращается `Future`-объект, который *позволяет проверить, завершена ли задача*, дождаться её результата и отменить выполнение.
```java
ExecutorService es = …
Future res = es.submit(() -> {/*… */ });

```

`ThreadPoolExecutor` - основная реализация пула потоков. Состоит из очереди задач и пула потоков. Позволяет настраивать:
- минимальное и максимальное количество потоков
- размер очереди задач
- время жизни неактивных потоков
- обработчик отклонённых задач (RejectedExecutionHandler)

`ScheduledExecutorService` - экзекьютор для периодических задач или задач, которые нужно запустить с задержкой.

`Executors` - утилитарный класс с фабричными методами для быстрого создания различных типов экзекьюторов:
- `newFixedThreadPool(int nThreads)` - пул фиксированного размера
- `newCachedThreadPool()` - пул с неограниченным числом потоков (создаются по необходимости). Хорош для задач с непредсказуемой нагрузкой, но может создать слишком много потоков и перегрузить систему
- `newSingleThreadExecutor()` - один поток для последовательного выполнения задач
- `newScheduledThreadPool(int corePoolSize)` - пул для планируемых задач
- `newSingleThreadScheduledExecutor()` - однопоточный пул для отложенных задач
- [[java newWorkStealingPool|newWorkStealingPool]] - экземпляр [[java ForkJoinPool|ForkJoinPool]] с числом потоков=числу ядер
- `newVirtualThreadPerTaskExecutor()` - экзекьютор с виртуальными потоками

[[java ForkJoinPool|ForkJoinPool]] - экзекьютор для задач, которые можно рекурсивно разбить на подзадачи и затем объединить их результат.

Использует несколько очередей задач и механизм [[java work-stealing алгоритм|work-stealing алгоритм]]. Если поток завершил свои задачи, он "крадет" задачи из очередей других потоков, чтобы не простаивать. Это обеспечивает балансировку нагрузки и эффективное использование всех процессорных ядер.

В [[JVM]] на старте запускается статический экземпляр `commonPool`. Число потоков внутри = числу ядер. Там выполняются задачи `StreamAPI` при включении `parallel`, а также задачи `CompletableFuture`, если пул явно не указан.

`commonPool` используется в разных частях приложения, поэтому не рекомендуется использовать блокирующие операции (запросы в БД, другие сервисы) в `Stream API` при включении `parallel`. Если в `CompletableFuture` нужно выполнить блокирующие операции, нужно передать отдельный экзекьютор.

## Обработка исключений в экзекьюторах

Задача передана через `execute()` - исключение останется внутри потока и не может быть перехвачено в вызывающем коде. Такое исключение можно поймать через глобальный обработчик непойманных исключений `Thread.setDefaultUncaughtExceptionHandler` или через переопределение метода `afterExecute()` в кастомном `ThreadPoolExecutor`

Задача передана через `submit()` - исключения сохраняются внутри объекта `Future`. При вызове `future,get()` будет выброшено `ExecutionException`, исходную ошибку можно получить через `future.exceptionNow()`

Если исключение не обработано, поток в экзекьюторе завершает работу, и создаётся новый поток.

## Альтернатива экзекьюторам

`CompletableFuture`. Это удобное API для асихронных операций. Под капотом задачи выполняются в переданном экзекьюторе или в `ForkJoinPool.commonPool()`. С помощью `CompletableFuture` удобно добавлять коллбэки при получении результата и обрабатывать исключения.

Дополнительные материалы:
[[Наглядно про CompletableFuture]]
[[Нюансы работы и выбора экзекьюторов]]
