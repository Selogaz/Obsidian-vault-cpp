---
tags:
  - note/specific/exact
  - category/work
aliases: []
deck: obsidian::work
created: 2025-05-21T13:21:22+03:00
updated: 2025-06-02T08:06:09+03:00
sr-due: 2025-06-12
sr-interval: 10
sr-ease: 181
---

**Frames**
—
Используется для:
- хранения данных и частичных результатов
- выполнения [[динамическое или позднее связывание|динамического связывания]]
- возврата значений для методов
- отправки исключений

Новый frame *создается* каждый раз, *когда вызывается метод*. Frame *уничтожается*, когда *завершается вызов метода*.
Frames выделяются из стека потока, создающего frame.
Каждый frame имеет собственный *массив локальных переменных, стек операндов и ссылку на пул констант* во время выполнения класса текущего метода. *Размеры* массива локальных переменных и стека операндов *определяются во время компиляции*. Размер структуры данных фрейма зависит только от реализации JVM. А память для этих структур выделяется в момент вызова метода.

Единственный фрейм, активный в любой точке данного потока управления - метода выполнения - называется **текущим фреймом**.
Его метод - **текущий метод**. Класс, в котором определен текущий метод - **текущий класс**. Операции над локальными переменными и стеком операндов выполняются со ссылкой на текущий фрейм[^1]
- [x] #task/inbox #category/work :[^1] И что это дает? Что будет, если выполнить без этой ссылки? Какую роль здесь играет ссылка, как она относится к операциям? ✅ 2025-05-23

Фрейм перестает быть текущим, если его метод вызывает другой метод или его метод завершается. Когда метод вызывается, новый фрейм создается и становится текущим, когда управление переходит к новому методу. При возврате метода текущий фрейм передает результат вызова метода в предыдущий фрейм. Текущий фрейм отбрасывается и предыдущий становится текущим. Фрейм, созданный потоком, является локальным для этого потока и на него не могут ссылаться другие потоки.

# [[Локальные переменные]]

Каждый фрейм содержит массив переменных, известных как его **локальные переменные**. Длина массива локальных переменных определяется во время компиляции. Единичная локальная переменная может хранить значения типа: `boolean, byte, short, char, int, float, reference or returnAddress`. Пара локальных переменных может хранить значения `long, double`.

Локальные переменные адресуются путем индексации. Индекс первой локальной переменной равен 0.

Значение `long, double` занимает две последовательные локальные переменные.

JVM использует локальные переменные для передачи параметров при вызове метода. При вызове метода класса все параметры передаются в последовательных локальных переменных, начиная с нулевой. При вызове метода экземпляра *локальная переменная 0 всегда используется для передачи ссылки на объект* (this), для которого вызывается метод экземпляра. Впоследствии параметры передаются с 1 переменной.

# [[Стеки операндов]]

Каждый фрейм содержит стек "последний вошел - первый вышел" - LIFO, известный как стек операндов. Максимальная глубина стека определяется *во время компиляции*.

Сразу после создания фрейма, стек операндов пуст. JVM предоставляет инструкции для *загрузки локальных переменных и констант в стек* операндов. Другие инструкции *берут* операнды из стека, *оперируют* над ними и *возвращают* результат обратно в стек. Стек также используется для подготовки параметров для передачи в методы и для получения результатов методов.

# [[Динамическое связывание в контексте фрейма|Динамическое связывание]]

Каждый *фрейм содержит ссылку* на [[run-time data areas#Run-time constant pool|run-time constant pool]] для типа текущего метода *для поддержки [[динамическое или позднее связывание|динамического связывания]]* кода метода. *Доступ* к вызываемым методам и переменным *осуществляется через символические ссылки* из class файла. Динамическое связывание *преобразует* эти *символьные ссылки* на методы *в конкретные ссылки* на методы, загружая классы по мере необходимости для разрешения еще не определенных символов, и *преобразует обращения* к переменным *в* соответствующие *смещения* в структурах хранения, связанных с расположением этих переменных во время выполнения.

Позднее связывание методов и переменных вносит изменения в другие классы.

# Нормальное завершение вызова метода

Вызов метода *завершается нормально, если* этот вызов *не вызывает исключение*. Если вызов текущего метода завершается нормально, то значение *может быть возвращено* вызывающему методу. Это происходит, когда метод выполняет одну из *инструкций возврата*, выбор которых должен соответствовать типу возвращаемого значения.

Текущий фрейм в этом случае используется для *восстановления состояния* инициатора, с *увеличенным* программным *счетчиком* инициатора, чтобы пропустить инструкцию вызова метода.

# Резкое завершение вызова метода

Вызов метода *завершается преждевременно, если* при выполнении инструкции JVM *выбрасывает исключение*, и это исключение *не обрабатывается* в методе. Или если исключение выбрасывает не JVM, а команда `throw`. Вызов метода, который завершается внезапно, *никогда не возвращает значение* своему вызывающему.

[^1]: Операции над этими данными (локальные переменные, стек операндов) выполняются *с использованием информации, связанной с этим фреймом*, что *гарантирует доступ* к нужным данным во время выполнения функции
