---
tags:
  - note/specific/code
  - category/java
aliases:
  - блокировки
deck: obsidian::java
created: 2025-09-26T10:10:59+03:00
updated: 2025-09-26T10:52:41+03:00
---

**блокировки**
—
```table-of-contents
```

используются, чтобы упорядочить конкурентный доступ к разделяемым ресурсам. Бывают двух видов:
- Пессимистичная
	- предполагает, что конфликты при изменении данных вероятны, поэтому доступ к записи блокируется сразу на время транзакции
	- подходит для спенариев с частыми изменениями одних и тех же данных
- Оптимистичная
	- предполагает, что конфликты редки. Проверка изменений происходит перед коммитом через версию или временную метку. Не блокирует данные на время транзакции, но требует обработки конфликтов.
	- идеально для случаев, когда операции чтения происходят гораздо чаще, чем запись

# Пессимистичная блокировка строк в Postgres

Пессимистичная блокировка реализована 4 способами, которые отличаются по силе: FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE и FOR KEY SHARE. На практике чаще используются два:

## SELECT ... FOR UPDATE

*блокирует строки, попавшие под условие*. Другие транзакции не смогут захватить блокировку, обновить или удалить эти данные. Обычно используется, когда в планах обновить строку в рамках транзакции.
Пример: заблокировать строку в id=1:
```sql
	  SELECT * FROM accounts WHERE id = 1 FOR UPDATE; 
```

## SELECT ... FOR SHARE

блокирует строки для чтения и даёт гарантию, что они не будут изменены во время транзакции. Несколько транзакций могут удержать такую блокировку одновременно. Обычно используется, когда надо что-то сделать на основе прочитанных данных и не нужно, чтобы они изменились.

Все блокировки снимаются после коммита транзакции.

Чтобы выбрать строки, на которых нет блокировок, используется
**SKIP LOCKED**:
```sql
SELECT * FROM jobs WHERE status = 'pending' FOR UPDATE SKIP LOCKED;
```
# Оптимистичная блокировка строк в Postgres

В таблицу добавляется поле с версией. При каждом изменении версия проверяется и обновляется:
```sql
UPDATE products SET price = 100, version = version + 1 WHERE id = 5 AND version = 2;
```

Поскольку обновление может не выполниться, полезно при оптимистичных блокировках проверять количество измененных строк с помощью RETURNING или наличие строк со старой версией.

# Пессимистичная блокировка строк в Spring Data JPA

реализуется аннотацией `@Lock` над запросом в репозитории. Параметр `LockModeType` определяет тип блокировки. Варианты `LockModeType`:
## PESSIMISTIC_READ
блокирует изменение записи до тех пор, пока транзакция не завершит свою работу, блокировку могут взять несколько транзакций. В Postres приводит к вызову SELECT ... FOR SHARE
## PESSIMISTIC_WRITE
блокирует изменения записи, пока транзакция не завершит свою работу. Только одна транзакция может взять этот лок. В Postgres приводит к вызову SELECT ... FOR NO KEY UPDATE (чуть более мощный аналог блокировки for share)
## PESSIMISTIC_FORCE_INCREMENT
аналогично PESSIMISTIC_WRITE, плюс увеличивает версию сущности. Полезно при вероятности [[java ABA-проблема|ABA-проблемы]] (когда для обнаружения изменений сравниваются старая и новая версии)

Блокировка удерживается до конца транзакции, поэтому методы с аннотацией `@Lock` должны вызываться из методов с аннотацией [[java Transactional|`@Transactional`]]

# Оптимистичная блокировка строк в SpringData JPA

Аннотация `@Version` над полем + аннотация `@Lock` над запросом в репозитории.

Варианты LockModeType:
## OPTIMISTIC
в случае успешной транзакции версия увеличивается
## OPTIMISTIC_FORCE_INCREMENT
версия увеличивается, даже если сама сущность не изменилась. Полезно в случаях, когда меняются дочерние сущности

При конфликте JPA автоматически выбрасывает OptimisticLockException

# Взаимоблокировки (deadlocks)
ситуация, когда две или более транзакций держат блокировки так, что взаимно блокируют друг друга

В Postgres блокировки строк - не отдельные объекты в памяти, а признаки в самих строках (поле xmax и флаги). Это позволяет быстро и экономно блокировать множество строк, но усложняет мониторинг и обнаружение.

Postgres может обнаружить дедлоки и прервать одну из транзакций. Но может и пропустить.

Базовые рекомендации для предотвращения и мониторинга дедлоков:
## Сортировать строки, которые будут заблокированы по id или другому неизменяемому полю
```sql
SELECT … FOR UPDATE SORT BY id LIMIT 5
```
## Добавить параметр log_lock_waits
В этом случае в журнал сообщений сервера будет попадать информация, если транзакция ждала дольше, чем deadlock_timeout

# Дополнительные материалы
[[Документация механизмы блокировки в Postgres]]
[[Подробно про блокировки часть 1]]
[[Подробно про блокировки часть 2]]
[[Как посмотреть блокировки]]
[[Много материалов про блокировки eng]]
[[Во что превращаются различные LockModeType в разных бд eng]]
