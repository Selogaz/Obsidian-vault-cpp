---
tags:
  - note/specific/code
  - category/java
aliases:
  - immutable
deck: obsidian::java
created: 2025-09-19T21:29:55+03:00
updated: 2025-10-06T19:27:35+03:00
sr-due: 2025-10-10
sr-interval: 4
sr-ease: 287
---

**immutable**
—
Объекты, которые не меняют своё состояние во время работы программы. Неизменяемость - важное свойство программ в функциональном стиле. В [[ООП]] наоборот, состояние объекта часто меняется.

✅ Простая работа в многопоточных приложениях, не нужна синхронизация
✅ Безопасное использование в качестве ключей в хэш-таблицах [[java HashSet|HashSet]], [[HashMap]]
✅ Беспроблемное кэширование

❌ Большее потребление памяти
❌ Сложности в реализации. Обычно просто сделать класс неизменяемым не приносит большой пользы, нужно использовать это свойство. Не всегда очевидно, как это сделать.

Как создать неизменяемый класс:
- Объявить класс `final`, чтобы его нельзя было наследовать
- Все поля сделать `private final`, чтобы их нельзя было изменить после инициализации
- Нет методов, меняющих значения полей
- Если в классе есть изменяемые объекты(например, коллекции, массивы), возвращать их копии или использовать неизменяемые обёртки
- Если изменяемые объекты передаются через конструктор, нужно записать их копию, чтобы исключить возможность изменений извне

Для продвинутых: в некоторых случаях класс может менять своё внутреннее состояние. Главное, чтобы класс выглядел неизменяемым со стороны пользователя. В неизменяемом классе может быть, например, ленивая загрузка поля.

Примеры неизменяемых классов:
- String. За счет неизменяемости для строк сделано много оптимизаций внутри [[JVM]]. Например, String pool, дедупликация, сохранение хэша
- Integer, Long, Double, Boolean
- Классы из пакета java.time (LocalDate, LocalDateTime). Они пришли на замену изменяемым классам из java.util.Date
- CopyOnWriteArrayList, CopyOnWriteArraySet

records приводит к созданию final класса с final полями, но не даёт должной защиты при наличии изменяемых полей. Необходимо самостоятельно создать копии в конструкторе:
```java
record Person(String name, List<String> hobbies) {
   public Person(String name, List<String> hobbies) {
      this.name = name;
      this.hobbies = List.copyOf(hobbies); // Защитная копия
   }
}

```

# Работа с неизменяемыми объектами

Для удобства работы в неизменяемый класс добавляются методы, которые создают новый объект, на основе переданного:
```java
LocalDate now = LocalDate.now();
LocalDate nextWeek = now.plusDays(7);

```

При вызове метода должно быть понятно, что создаётся новый объект, который надо куда-то присвоить. Для таких методов редко используются глаголы. Часто методы называются with*:
```java
order = order.withDeliveryDate(…);
Order o = order.cancelled();
String s = str.toLowerCase();
LocalDate l = now().plusDays(12); 
String sub = str.substring(1);

```

Исключение: если класс использует `Fluent API`, обычно используются глаголы:
```java
list.stream().map(…).filter(…)…

```

В многопоточной среде при активном создании и передаче объектов между потоками, очень важно наличие final у полей и их инициализация в конструкторе.
```java
public class ValueClass {
   final int value;
   public ValueClass(int value) {
      this.value = value;
   }
   // …
}

```

Только тогда [[JVM]] даёт гарантию видимости. В противном случае есть риск, что другой поток не увидит проинициализированных полей.

Для создания неизменяемых объектов часто полезен паттерн [[java паттерны gof#java builder Builder|Builder]]

# Дополнительные материалы

[[Пример работы с неизменяемыми объектами в многопоточной среде]]
[[Создание билдера для работы с неизменяемыми объектами]]
