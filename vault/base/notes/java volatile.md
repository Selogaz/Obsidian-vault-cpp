---
tags:
  - note/specific/code
  - category/java
aliases:
  - volatile
deck: obsidian::java
created: 2025-09-19T22:06:06+03:00
updated: 2025-10-08T19:25:51+03:00
sr-due: 2025-10-12
sr-interval: 4
sr-ease: 270
---

**volatile**
—
ключевое слово, которое гарантирует, что поток всегда прочитает актуальное значение переменной. Без него изменений переменной в одном потоке могут не сразу (или вообще не) отобразиться в другом.

При работа с volatile в [[JVM]] добавляются барьеры памяти (memory barriers). Благодаря этому достигаются гарантии:

- Видимость: изменения, сделанные в одном потоке, сразу видны другим потокам
- Запрет переупорядочивания: компилятор и процессор не могут менять порядок операций вокруг чтения/записи volatile-переменной. Поток не работает с значениями из кэшей процессора и потока. Снижается вероятность появления других многопоточных проблем для переменных рядом.

Действие volatile распространяется только на чтение и присвоение значения одной переменной. Если новые значения вычисляются на основе предыдущего, а не просто присваиваются, возможна ошибка "потерянный апдейт":
```java
volatile int value;
value = 5;          //  другие потоки при чтении увидят 5
value = value + 5;  // возможен потерянный апдейт, если два потока одновременно вызовут подобную операцию, одно изменение будет затёрто изменением другого потока.

```

Если volatile стоит у объекта, то свойство видимости распространяется только на изменение ссылки, а не на внутренние поля
```java
volatile User user = new User("Alice");
…
user = new User("John"); // другие потоки при чтении увидят джона
user.setPhone("123"); // меняется поле объекта, другие потоки могут прочитать старое значение.

```

[[Полезный паттерн использования volatile и Atomic с неизменяемыми объектами]]
