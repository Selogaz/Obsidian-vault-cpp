---
tags:
  - note/specific/code
  - category/java
aliases:
  - Паттерны отказоустойчивости микросервисов
deck: obsidian::java
created: 2025-09-28T04:59:46+03:00
updated: 2025-09-28T04:59:46+03:00
---

**Паттерны отказоустойчивости микросервисов**
—
## Timeout
ограничение времени ожидания ответа

Предотвращает бесконечное ожидание ответа в случае сбоя/ошибки на другой стороне.

Deadline propagation - клиент в запросе к серверу передаёт время, к которому нужен ответ. Сервер в процессе обработки запроса регулярно проверяет: не закончилось ли это время. Если закончилось, можно завершать обработку запроса ошибкой.

## Retry

Повторение запроса при ошибке. Полезен, если сбой связан с кратковременной ошибкой, например, с недоступностью сети.

Стратегии повторов:
- Fixed Retry - одинаковый интервал между попытками
- Exponential Backoff - интервал растет экспоненциально
- Exponential Backoff with Jitter - случайное смещение (джиттер) распределяет нагрузку на восстановившийся сервис

Дополнительные параметры:
- Ограничение количества попыток
- Retry Budget - контроль общего количества ретраев для сервиса Например, не более 10% от числа успешных запросов.
- Повтор только при конкретных ошибках. Выполнять ретраи только при ошибках сети или временных сбоях, исключая постоянные ошибки, чтобы не нагружать систему.

Возможные проблемы:
- ❌ Thundering herd / Retry storm - множество компонентов начинают повторно вызывать операции после ошибки. Вместо того, чтобы дать системе восстановиться, шквал одновременных повторных попыток только усиливает нагрузку на и без того проблемный компонент.
	- Что делать: использовать стратегию exponential backoff + джиттер, добавить лимиты на ретраи (retry budget), добавить <font color="#ffff00">Circuit Breaker</font>
- ❌ Двойная обработка сообщения, если несколько запросов дошли до получателя.
	- Чтобы избежать проблемы, запросы должны быть [[java идемпотетность|идемпотетными]]
- ❌ Потеря задачи / сообщения - если сервис упадет, задача так и не будет выполнена. Эта проблема не относится к ретраям, но часто идет рядом. Что делать:
	- Вместо синхронного запроса отправлять задачу в очередь или записывать в БД. Другая сторона забирает оттуда

## Fallback

При ошибке используется заданное значение или другой сценарий. Fallback имеет смысл только при технических ошибках.

Пример: если БД не отвечает, берётся значение по умолчанию или делается запрос в другую систему

- ❌ Недостатки: при неверной реализации Fallback может скрывать наличие проблемы, искажать метрики и ухудшать пользовательский опыт

## Rate Limiter
контролирует количество запросов к сервису, чтобы не перегрузить его. Запросы либо отбрасываются либо ставятся в очередь.

Паттерн полезен при пиковых нагрузках или в сценариях с агрессивными клиентами.

Как работает: Считает запросы от идентификатора клиента (IP, аккаунт, IP + URL). При превышении лимита последующие запросы блокируются (с кодом 429 Too Many Requests) или откладываются до окончания временного окна.

Основные стратегии работы с лимитами:
- Token Bucket - система даёт ограниченное число токенов за фиксированный период. Каждый запрос тратит 1 токен. Если токены закончились, запрос блокируется или отклоняется. Позволяет равномерно распределять нагрузку.
- Leaky Bucket - запросы копятся в очереди, и обрабатываются сервисом по возможности. При переполнении очереди новые запросы отбрасываются
- Fixed Window - каждую минуту запускается счетчик запросов. Если число запросов в окне превышено, запросы блокируются. Есть риск пиковых нагрузок в конце окна.
- Sliding Window - запросы считываются за скользящее окно времени на основе времени каждого запроса, что обеспечивает более точный контроль нагрузки

## HealthCheck

Система следит за состоянием сервисов, чтобы быстро обнаружить и исправить проблемы.

В Kubernetes определены 2 типа проверок:
- liveness probe - жив ли сервис, не завис ли он
- readiness probe - готов ли сервис принимать запросы. Например, сервис может быть запущен, но сейчас инициализируется или занимается перерасчетом

## Bulkhead

Ограничение ресурсов между сервисами. Название дано по аналогии с отсеками корабля: если корпус пробит, вода затопит лишь один отсек, а корабль останется на плаву. В контексте микросервисов для каждого сервиса ограничивается число потоков, соединений к БД, память, выделенный CPU.

## Circuit Breaker (предохранитель)

Отключает сервис, если тот часто падает, чтобы остальные не пострадали и система успевала восстановиться. Быстрая изоляция проблемных сервисов. Защита от каскадных сбоев.

Минус - сложная настройка, много параметров.

Circuit Breaker использует 3 состояния:
- Закрытое. Всё нормально, запросы проходят к сервису
- Открытое. Запросы сразу отклоняются, чтобы не создавать доп. нагрузку на упавший сервис. Пример условий, когда происходит переход: более 50% сбоев за 10 сек, 10 сбоев подряд
- Полуоткрытое. После некоторого времени Circuit Breaker отправляет несколько тестовых запросов. Если всё нормально - он переходит в закрытое состояние. Если нет - остаётся в открытом состоянии

## Паттерны на практике

Наиболее полное сочетание паттернов для обработки ошибок от другого сервиса выглядит так:
- Сервис получил ошибку от другого сервиса
- Делает несколько retry-попыток на уровне отдельного запроса
- Если общий процент ошибок становится высоким, срабатывает Circuit Breaker, чтобы дать сервису восстановиться
- В этот момент сервис-клиент использует Fallback

## Как и где реализуются паттерны

- В коде сервиса. Spring библиотеки, Resilence4j, Hystrix. Можно вынести функционал в [[Spring Boot]] стартер, чтобы не повторять код на каждом сервисе
- Sidecar / Service proxy. Рядом с каждым сервисом поднимается компонент, через который идет весь трафик. В нём задаётся логика работы с ошибками - ретраи, circuit breaker, хелсчеки и тд
- Инфраструктура / [[java service mesh|service mesh]]. Например, Kubernetes, Openshift могут самостоятельно производить хелсчек, выставлять лимиты, таймауты и тд. В <font color="#ffff00">Nginx</font> есть механизм Rate Limiter

# Дополнительные материалы

[Демонстрация retry сценариев](“Хороший ретрай, плохой ретрай, или История одного падения” ([jirfag, 2023](zotero://select/library/items/GW5MFPB4)) ([snapshot](zotero://open-pdf/library/items/IH38T597?sel=h1%20%3E%20span&annotation=UTEIA2UR)))
[Стратегии борьбы с Retry storm](“Retry storm в распределенных системах” ([proselyte, 2025](zotero://select/library/items/5XCMPRAB)) ([snapshot](zotero://open-pdf/library/items/HA9V932F?sel=h1&annotation=CAJ7XIYN)))
[Причины и меры избежания каскадных падений](“Addressing Cascading Failures” ([“Причины и меры избежания каскадных падений”](zotero://select/library/items/RJ5VK4IG)) ([snapshot](zotero://open-pdf/library/items/B3LX8M3L?sel=%23addressing-cascading-failures&annotation=AJKXY4P9)))
[Настройка параметров Circuit Breaker](“Circuit Breaker Policy Fine-tuning Best Practice” ([Lyu 🚀, 2025](zotero://select/library/items/UTIJ56X3)) ([snapshot](zotero://open-pdf/library/items/3TMWDBZK?sel=h1&annotation=KVK8NRW5)))
[Много деталей про Circuit Breaker](“Circuit Breaker pattern” ([claytonsiemens77](zotero://select/library/items/QF2UENP7)) ([snapshot](zotero://open-pdf/library/items/ZJL42TBI?sel=%23circuit-breaker-pattern&annotation=BMXHHNG7)))
[Пример реализации Rate Limiter](“Rate Limiter” ([hikitani, 2025](zotero://select/library/items/MRXJ5WMZ)) ([snapshot](zotero://open-pdf/library/items/WWQB4H6V?sel=h1%20%3E%20span&annotation=FZS4DX2P)))
