Лист - динамическая структура данных, которая реализована в виде двусвязного списка. Имеет более быстрые операции добавления и удаления элементов.
```c++
#include <list>

list<int> myList = {99, 15, 64, 99, 99, 99};
myList.unique();//удалит одинаковые элементы, стоящие рядом(две цифры 99 в конце)
myList.sort();//сортирует элементы от самого маленького к наибольшему
myList.reverse();//переставляет элементы в обратном порядке
myList.clear();//Удаляет все элементы в листе
auto it = myList.begin();
myList.insert(it, 111);//вставляет элемент туда, куда указывает итератор. В данном случае, в начало
advance(it, 3);//сдвиг итератора на 3 элемента
myList.erase(it);//удаление элемента, на который указывает итератор
myList.remove(1000);//удаление элемента, указанного в скобках
myList.assign(3, 1651651);//очистит лист и добавит 3 элемента 1651651

list<int> myList2 = {19, 66, 44, 22};
myList.assign(myList2.begin(), myList2.end());//очистим лист и заполним его значениями лист2

for(auto it = myList.begin(); it != myList.end(); ++i) {//Предпочтительнее!!
	cout << *it << endl;
}

for(auto it = myList.begin(); it != myList.end(); i++) {//создается ненужный временный объект
	cout << *it << endl;
}
```
Разница в использовании префиксного и постфиксного инкремента/декремента для итераторов в том, что в случае префиксного итератора, в теории, просто изменяется состояние объекта, и потом он возвращается, а при использовании постфиксного инкремента, состояние также изменяется, но возвращается объект с предыдущим состоянием, т.е. для этого компилятору необходимо создать ещё 1 объект. Это влияет на скорость работы. Но, вроде как современные компиляторы уже могут сами оптимизировать подобные случаи, и скорость работы не отличается.Если использование префиксного и постфиксного инкремента не влияет на правильность ответа, то предпочтительно использовать префиксный инкремент.

[[C++]] [[stl]] [[namespace std]] [[Итератор]] 