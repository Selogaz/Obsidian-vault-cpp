```c++
int arr[] = {10, 3, 4, 5, 7, 11};
int arr2[] = {10, 3, 4, 5, 7, 11};
bool result = equal(begin(arr), end(arr), begin(arr2));
cout << result << endl;
```
При использовании собственных типов данных необходимо перегрузить оператор равенства, либо использовать предикат.
Для того, чтобы вывелась 1 необходимо, чтобы коллекции были не только одинаковыми по содержанию, но и одинакового размера.
```c++
int arr[] = {10, 3, 4, 5, 7, 11};
int arr2[] = {10, 3, 4, 5, 7, 11, 2};
bool result = equal(begin(arr), end(arr), begin(arr2));
```
При такой записи алгоритм отработает некорректно и выведет 1. Чтобы избежать такой ситуации, нужно явно указывать конец второй коллекции:
```c++
bool result = equal(begin(arr), end(arr), begin(arr2), end(arr2));
```

Чтобы  корректно сравнивать коллекции с одинаковым набором элементов, но в неупорядоченном виде, их нужно сначала отсортировать:
```c++
int arr[] = {11, 3, 4, 5, 7, 10};
int arr2[] = {10, 3, 4, 5, 7, 11};
sort(begin(arr), end(arr));
sort(begin(arr2), end(arr2));
bool result = equal(begin(arr), end(arr), begin(arr2), emd(arr2));
```

[[C++]] [[stl]] [[алгоритмы]] [[Предикат]] [[Перегрузка оператора равенства]] [[stl mismatch]] 