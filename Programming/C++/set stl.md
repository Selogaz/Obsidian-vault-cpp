Сет является контейнером, реализующим бинарное дерево.  Нет методов push, pop или квадратных скобок. Данные хранит упорядочено. Не хранит повторяющиеся значения
```C++
#include <set>

set<int> mySet = {5, 45, 35, 11, 86};
auto it = mySet.find(10);//ищем число 10. Метод вернёт итератор
mySet.end();//если указанного числа нет в контейнере, то итератор будет указывать на end
auto reresult = mySet.insert(5);//метод insert возвращает 2 значения:
/*
*Первое значение является итератором, указывающим на добавленный элемент в коллекции
*Второе значение true, если получилось добавить элемент и false, если не получилось
*/
auto result = mySet.erase(5);//удаление элемента
//если удаляемого элемента не существует, то erase возвращает 0, в противном случае единицу.
int value;
cin >> value;
if (mySet.find(value) != mySet.end()) {//т.к. в случае ненахождения числа метод find будет указывать за последний элемент сэта( на end)
	cout << "число" << value << " найдено"<<endl;
} else {
	cout << "число " << value << " отсутствует" << endl;
}



set<int> yourSet;

for (int i = 0; i < 20; i++) {
	yourSet.insert(rand() % 10);
}

for (auto &item : yourSet) {
	cout << item << endl;//выведет числа от 0 до 9, хоть и итераций 20. Дубликаты не будут созданы
}
```
![[set.png]]



![[set_2.png]]

создание объекта типа set: 
set<тип данных> имя древа; 
Добавить элемент: 
Добавить в set можно только УНИКАЛЬНЫЕ значения: 

set<тип данных> имя древа = { , , , , , };
mySet.insert(значение) - добавляет элемент в древо. Если элемент успешно добавлен в коллекцию, возвращается пара: итератор на тот элемент который мы передали + булевая переменная(в данном случае она будет true). 
Если элемент существует в коллекции, то первое значение будет итератор указывающий на этот элемент В КОЛЛЕКЦИИ, второй: булевая переменная (false в этом случае); 
Перебрать все элементы древа: 
for (auto &item : имя нашего древа)
{ 
cout << item << endl; 
} 
myset.find(значение) - поиск указанного элемента. .find() - возвращает итератор на тот элемент который мы передали, при условии, что он присутствует. В противном случае он вернет итератор указывающий на область в памяти за древом(проще говоря вернет .end())
myset.end() - возвращает итератор который находится за древом. 
myset.erase(элемент) - удаляет переданный элемент. Возвращает логический 0 если: элемент не получилось удалить. Возвращает логическую 1 если: элемент получилось удалить. 

multiset: 
Создание объекта класса multiset: multyset<тип данных> name; Или multyset<тип данных> имя мультисета = { , , , , , , , , , }; 
Можно добавлять любые значения даже повторные. mymultiset.lower_bound(значение) - вернет итератор указывающий на самое первое значение которое мы передали. 
mymultiset.upper_bound(значение) - вернет итератор на тот элемент, который идет ПОСЛЕ того значение которое мы передали, и которое не повторяет переданное значение. mymultiset.equale_range(значение) - вернет диапазон значений от .lower_bound до .upper_bound.

```c++
#include <set>
multiset<int> myMultiset = {1,1,16,48,66};//возможно добавлять одинаковые элементы
auto it1 = myMultiset.lower_bound(1);//вернет итератор на первое вхождение числа 1
auto it2 = myMultiset.upper_bound(1);//вернет итератор на наименьшее число, которое больше 1. В данном случае 16
auto a = myMultiset.equal_range(1);//вернет диапазон между lower и upper bound. В данном случае {1, 16}
```

[[C++]] [[stl]] [[Бинарное дерево]] [[Итератор]] 