Техника для удаления элементов из контейнеров STL.
Идиома состоит из двух шагов:
1. Перемещение:  ```c++ std::remove_if``` или ```c++ std::remove``` используются для перестановки элементов таким образом, чтобы удаляемые элементы перемещались в конец контейнера, а остальные элементы - в его начало. ```c++ std::remove_if``` принимает предикат(функция, возвращающая true/false) как дополнительный аргумент, чтобы уточнить условие для удаления.
2. Удаление: ```c++ std::vector::erase``` или похожая функция используется для удаления элементов из контейнера.  Принимает два итератора, определяющих диапазон элементов, которые должны быть удалены.
 ```cpp
#include <algorithm>
#include <vector>

bool is_even(int i) { return i % 2 == 0; }

int main() {
   std::vector<int> nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

   nums.erase(std::remove_if(nums.begin(), nums.end(), is_even), nums.end());

   return 0;
}
```
В этом примере мы хотим удалить все even элементы из контейнера. std::remove_if перемещает все odd элементы в начало вектора, а std::vector::erase удаляет остальные элементы.

=====================================

Удаление элементов из вектора - вещь не совсем тривиальная. Безусловно, в STL есть интерфейс для этого, бери да вызывай. Проблема в том, что удаление вызывает копирование всех элементов вектора, которые находятся правее от удаляемого элемента. То есть, в среднем, сложность удаления одного элемента контейнера будет линейной. А сложность очистки всего контейнера - квадратичная. Это все очень печальные результаты. И хоть для последовательности упорядоченных элементов нет стандартного алгоритма удаления из середины, для вектора, в котором порядок неважен, такой алгоритм есть.  
  
Нам нужно лишь свопнуть удаляемый элемент с последним элементом в векторе и очистить последнюю с конца ячейку. Таким образом, удаление будет занимать всего 2 действия, а значит сложность этой операции - константная. Звучит намного лучше.  
  
А что, если нужно отфильтровать массив по какому-то критерию? Ну удалить все ячейки, которые обладают какими-то характеристиками. Например, из массива удалить все числа, кратные 5. Надо тогда в цикле проделать действия из предыдущего абзаца и все будет пучком.  
  
Однако, есть ощущение, что это задача слишком общая и хотелось бы иметь для нее какое-то более элегантное решение, чем каждый раз писать цикл. Можно конечно объявить функцию, но все-таки хочется чего-то стандартного.  
  
И такое есть. В плюсах это называется remove-erase idiom. Идиома удаления-очистки. Какой у меня прекрасный английский)  
Решение хоть и стандартное, но не прям очень элегантное. Ну а что вы хотели? Это плюсы все-таки.  
Судя по названию, надо просто скомбинировать стандартный алгоритм std::remove (или std::remove_if) и метод вектора std::vector::erase.  
На картинке снизу можете увидеть, как конкретно эта комбинация решает задачу удаления элементов.![[Pasted image 20240117065050.png]]

[[C++]] [[Идиома NVI]]  [[find-erase]] 