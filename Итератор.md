С помощью итератора можно "положить" индекс в переменную и управлять им 

```c++
vector<int> myVector = {1, 9, 44, 422, 676, 78};
vector<int>::iterator it;
it = myVector.begin();//кладем в итератор первый элемент вектора
cout << *it << endl;//вывод значения итератора (1)
cout << *(it + 3) << endl;
*it = 1000;//теперь первый элемент веткора будет не 1, а 1000
it++;//перейти на следующий элемент в коллекции

for(vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++) {
	cout << *i << endl;//вывод всех элементов вектора
}
for(vector<int>::const_iterator i = myVector.cbegin(); i != myVector.cend(); i++) {//вариант с константным итератором
	cout << *i << endl;
}
for(vector<int>::reverse_iterator i = myVector.rbegin(); i != myVector.rend(); i++) {//перебор с конца до начала
	cout << *i << endl;
}

//*(it + 3) и advance(it,3); равнозначные записи. Первая может быть недоступна

```

У вектора итератор произвольного доступа. т.е. можно перейти не просто на следующий элемент, но и сразу на несколько (it+=2)

[[C++]] [[ООП]] [[vector]] [[stl]] [[namespace std]]